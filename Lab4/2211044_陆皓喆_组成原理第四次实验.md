# <center>组成原理实验课程第四次实验报告</center>

<h5 align="center">实验名称：ALU模块实现   班级：李涛老师  学生姓名：陆皓喆  学号：2211044</h5 align="center">

<h5 align="center">指导老师：董前琨    实验地点：实验楼A306  实验时间：2024.05.09</h5 align="center">



# 一、实验目的

1. 熟悉$MIPS$指令集中的运算指令，学会对这些指令进行归纳分类。
2. 了解$MIPS$指令结构。
3. 熟悉并掌握$ALU$的原理、功能和设计。
4. 进一步加强运用$verilog$语言进行电路设计的能力。
5. 为后续设计$cpu$的实验打下基础。



# 二、实验内容说明

请结合实验指导手册中的实验四（$ALU$模块实现实验）完成功能改进，实现一个能够完成更多运算的$ALU$，注意以下几点：

1. 原始代码中只有表$5.1$中的$11$种运算，请另外补充至少三种不同类型运算（**比较运算、位运算、数据加载运算**等）。
2. 实验报告中原理图参考$5.3$，只画出补充的运算部分即可，报告中展示的结果应位补充运算的计算结果。
3. 本次实验报告不需要有仿真结果，但需要有实验箱上箱验证的照片，同样，针对照片中的数据需要解释说明。
4. 实验报告模板参考百度云盘文件，注意提交截至时间为$5$月$18$日下午$18:00$。



# 三、实验原理图和实验原理

## 3.1 ALU模块原理图

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab4\2211044_陆皓喆_组成原理第四次实验.assets\image-20240509161942707.png" alt="image-20240509161942707" style="zoom:50%;" />

​	此处我们还是跟原始的图像保持不变，不需要做改动。



## 3.2 顶层模块原理图

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab4\2211044_陆皓喆_组成原理第四次实验.assets\image-20240509162019818.png" alt="image-20240509162019818" style="zoom:50%;" />



## 3.3 实验原理

### 3.3.1 ALU运算重排

​	首先，我们需要做的就是将原先的$11$位控制$ALU$运算的位数进行缩减，从$11$位缩小到$4$位。我们发现，利用四位二进制数也是可以完成至少$15$种运算的选择的，所以我们此处选择使用$4$位二进制来作为我们的$ALU$运算选择器。前面的$13$种运算(包括不计算)，我们不改变其顺序，还是按照$0-12$排，也就是十六进制的$0-C$。后面的$D,E,F$，我们按照顺序依次设置为**有符号比较，大于置位**；**按位同或**；**低位加载**，如下表所示：

| CONTR |         ALU操作          |
| :---: | :----------------------: |
|   0   |            无            |
|   1   |           加法           |
|   2   |           减法           |
|   3   |   有符号比较，小于置位   |
|   4   |   无符号比较，小于置位   |
|   5   |          按位与          |
|   6   |         按位或非         |
|   7   |          按位或          |
|   8   |         按位异或         |
|   9   |         逻辑左移         |
|   A   |         逻辑右移         |
|   B   |         算数右移         |
|   C   |         高位加载         |
| **D** | **有符号比较，大于置位** |
| **E** |       **按位同或**       |
| **F** |       **低位加载**       |



### 3.3.2 原始12种运算原理

#### 3.3.2.1 加法&减法

​	我们调用实验一中的`adder.v`模块就可以完成运算！



#### 3.3.2.2 有符号比较，小于置位

​	根据参考$pdf$上的运算规则，我们很快可以推出：

```verilog
slt_result = (alu_src1[31] & ~alu_src2[31]) | (~(alu_src1[31]^alu_src2[31]) & adder_result[31])
```

​	通过这个表达式我们就可以实现我们的小于置位功能。



#### 3.3.2.3 无符号比较，小于置位

​	对于$32$位无符号比较的小于置位，可在其高位前填$0$组合为$33$位正数的比较，即`{1’b0, src1}`和`{1’b0, src2}`的比较，最高位符号位为$0$。对比表$5.2$可知，对于正数的比较，只要减法结果的符号位为$1$，则表示小于。而$33$位正数相减，其结果的符号位最终可由$32$位加法的`cout+1’b1`得到，如图$5.5$。故无符号$32$位比较小于置位运算结果表达式为：`sltu_result = ~adder_cout`。

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab4\2211044_陆皓喆_组成原理第四次实验.assets\image-20240509163613245.png" alt="image-20240509163613245" style="zoom:50%;" />



#### 3.3.2.4 按位与&按位或非&按位或&按位异或

```verilog
    assign and_result = alu_src1 & alu_src2;      // 与结果为两数按位与
    assign or_result  = alu_src1 | alu_src2;      // 或结果为两数按位或
    assign nor_result = ~or_result;               // 或非结果为或结果按位取反
    assign xor_result = alu_src1 ^ alu_src2;      // 异或结果为两数按位异或
```

​	我们使用一些简单的逻辑运算就能实现这四种运算法则，如上所示。



#### 3.3.2.5 逻辑左移&逻辑右移&算数左移

```verilog
     // 逻辑左移
    wire [31:0] sll_step1;
    wire [31:0] sll_step2;
    assign sll_step1 = {32{shf_1_0 == 2'b00}} & alu_src2                   // 若shf[1:0]="00",不移位
                     | {32{shf_1_0 == 2'b01}} & {alu_src2[30:0], 1'd0}     // 若shf[1:0]="01",左移1位
                     | {32{shf_1_0 == 2'b10}} & {alu_src2[29:0], 2'd0}     // 若shf[1:0]="10",左移2位
                     | {32{shf_1_0 == 2'b11}} & {alu_src2[28:0], 3'd0};    // 若shf[1:0]="11",左移3位
    assign sll_step2 = {32{shf_3_2 == 2'b00}} & sll_step1                  // 若shf[3:2]="00",不移位
                     | {32{shf_3_2 == 2'b01}} & {sll_step1[27:0], 4'd0}    // 若shf[3:2]="01",第一次移位结果左移4位
                     | {32{shf_3_2 == 2'b10}} & {sll_step1[23:0], 8'd0}    // 若shf[3:2]="10",第一次移位结果左移8位
                     | {32{shf_3_2 == 2'b11}} & {sll_step1[19:0], 12'd0};  // 若shf[3:2]="11",第一次移位结果左移12位
    assign sll_result = shf[4] ? {sll_step2[15:0], 16'd0} : sll_step2;     // 若shf[4]="1",第二次移位结果左移16位
```

​	我们拿逻辑左移来举例，这主要分为三个步骤：

* 第一步根据移位量低$2$位，即 $[1:0]$ 位，做第一次移位；
* 第二步在第一次移位基础上根据移位量 $[3:2]$ 位做第二次移位；
* 第三步在第二次移位基础上根据移位量$[4]$位做第三次移位。



#### 3.3.2.6 高位加载

​	专门用于设置寄存器中常数的高$16$位置。将$op2$低$16$位存放到寄存器的高$16$位，结果的低$16$位用$0$填充。

```verilog
    assign lui_result = {alu_src2[15:0], 16'd0};  // 立即数装载结果为立即数移位至高半字节
```



### 3.3.3 新增三种运算原理

#### 3.3.3.1 有符号比较，大于置位

​	跟我们上面的小于置位是基本相同的，只需要将我们最后的逻辑取反就可以了。但是考虑到更换方向之后我们会出现等于的情况，我们需要进行设置，因此我们增设一个`adder_zero`值，用于排除相等的情况。这样就可以处理相等的情况了。

​	其中，`adder_zero`是对结果` adder_result`进行或缩位运算，当源操作数$1$=源操作数$2$时，`adder_zero`为$0$，不置位。因此，大于置位的实现是：`~（小于置位表达式）& adder_zero`，即不满足小于置位且两操作数不相等的就是大于置位。



#### 3.3.3.2 按位同或

​	就是我们前面的按位异或的取反，我们只需要在我们前面的代码上加上一个取反符号就可以了！

```verilog
    assign nxor_result = ~xor_result;             // 同或结果为异或取反
```



#### 3.3.3.3 低位加载

​	和高位加载也是一样的，只不过我们选取的位数从高位变成了低位，代码如下所示。

```verilog
    assign hui_result = { 16'd0,alu_src2[15:0]};
```



# 四、实验步骤

## 4.1 复现

​	我们按照原先提供的代码进行复现，输入我们的两个输入数与我们的$ALU$操作数，进行复现验证。我们输入两个数，分别是$10101010 $和$02020202 $​，在硬件上读取对应的结果，此部分的结果我们记录在该报告的**第五部分——实验结果分析：复现**中。



## 4.2 改进

### 4.2.1 代码修改

#### 4.2.1.1 对alu.v的修改

​	首先，我们对我们的$ALU$运算的控制信号位数进行了修改，原先需要$12$个二进制来确定我们的操作，现在我们只需要$4$位二进制了，所以我们将位宽修改为$[0:3]$

```verilog
	input  [3:0] alu_control,  // ALU控制信号
```

​	然后，我们需要添加我们新的三个功能，我们新增三个$wire$，分别表示我们的三个新运算

```verilog
    wire [31:0] sgt_result;
    wire [31:0] nxor_result;
    wire [31:0] hui_result;
```

​	然后，对应的我们需要将16种运算方式与我们的四位二进制去对应起来，我们需要编写以下的代码来完成这个任务：

```verilog
    //修改此处代码，将其改为4位确定运算符号
    assign alu_add  = (~alu_control[3])&(~alu_control[2])&(~alu_control[1])&(alu_control[0]);//0001
    assign alu_sub  = (~alu_control[3])&(~alu_control[2])&(alu_control[1])&(~alu_control[0]);//0010
    assign alu_slt  = (~alu_control[3])&(~alu_control[2])&(alu_control[1])&(alu_control[0]); //0011
    assign alu_sltu = (~alu_control[3])&(alu_control[2])&(~alu_control[1])&(~alu_control[0]);//0100
    assign alu_and  = (~alu_control[3])&(alu_control[2])&(~alu_control[1])&(alu_control[0]); //0101
    assign alu_nor  = (~alu_control[3])&(alu_control[2])&(alu_control[1])&(~alu_control[0]); //0110
    assign alu_or   = (~alu_control[3])&(alu_control[2])&(alu_control[1])&(alu_control[0]);  //0111
    assign alu_xor  = (alu_control[3])&(~alu_control[2])&(~alu_control[1])&(~alu_control[0]);//1000
    assign alu_sll  = (alu_control[3])&(~alu_control[2])&(~alu_control[1])&(alu_control[0]); //1001
    assign alu_srl  = (alu_control[3])&(~alu_control[2])&(alu_control[1])&(~alu_control[0]); //1010
    assign alu_sra  = (alu_control[3])&(~alu_control[2])&(alu_control[1])&(alu_control[0]);  //1011
    assign alu_lui  = (alu_control[3])&(alu_control[2])&(~alu_control[1])&(~alu_control[0]); //1100
    //补充---------------------------------------------
    assign alu_sgt  = (alu_control[3])&(alu_control[2])&(~alu_control[1])&(alu_control[0]);  //1101
    assign alu_nxor  = (alu_control[3])&(alu_control[2])&(alu_control[1])&(~alu_control[0]); //1110
    assign alu_hui  = (alu_control[3])&(alu_control[2])&(alu_control[1])&(alu_control[0]);   //1111
```

​	然后，我们分别编写三个新的功能模块，在上一个版块内已经有说明，此处不再详细的介绍原理，给出我们的修改后的代码：

**有符号比较，大于置位：**

```verilog
wire adder_zero;
assign adder_zero=|adder_result; 
assign sgt_result[31:1] = 31'd0;
assign sgt_result[0] = ~((alu_src1[31] & ~alu_src2[31]) | (~(alu_src1[31]^alu_src2[31]) & adder_result[31])) & adder_zero;
```

​	这一部分就是，我们只需要修改我们的小于置位的部分就可以完成我们的大于置位了

**按位同或：**

```verilog
	assign nxor_result = ~xor_result;             // 同或结果为异或取反
```

​	这一部分很简单，就是将我们前面的异或的结果取反就可以了

**低位加载：**

```verilog
    assign hui_result = { 16'd0,alu_src2[15:0]};
```

​	跟我们的高位加载是一样的，只需要将我们的读取的位数换一下就可以了

​	最后，我们还需要将我们这三个函数输出的结果存储到我们的`alu_result`中，只需要增加三行，将我们的输出与函数相对应就可以了！

```verilog
    // 选择相应结果输出
    assign alu_result = (alu_add|alu_sub) ? add_sub_result[31:0] : 
                    alu_slt           ? slt_result  :
                    alu_sltu          ? sltu_result :
                    alu_and           ? and_result  :
                    alu_nor           ? nor_result  :
                    alu_or            ? or_result   :
                    alu_xor           ? xor_result  :
                    alu_sll           ? sll_result  :
                    alu_srl           ? srl_result  :
                    alu_sra           ? sra_result  :
                    alu_lui           ? lui_result  :
                    alu_sgt           ? sgt_result  ://有符号数比较，大于置位
                    alu_nxor          ? nxor_result ://按位同或
                    alu_hui           ? hui_result  ://低位加载
                    32'd0;
```



#### 4.2.1.2 对alu_display.v的修改

​	首先还是一样的，我们先修改我们的位宽，将其从$12$修改为$4$

```verilog
	reg   [3:0] alu_control;  // ALU控制信号
```

​	然后对应的，我们在输出中也需要对应的进行修改

```verilog
//当input_sel为00时，表示输入数控制信号，即alu_control
always @(posedge clk)
begin
    if (!resetn)
    begin
        alu_control <= 12'd0;
    end
    else if (input_valid && input_sel==2'b00)
    begin
        alu_control <= input_value[3:0];
    end
end
```

​	这样我们所有的代码都修改完了！直接运行就可以了



### 4.2.2 修改后的源代码

#### 4.2.2.1 alu.v

```verilog
`timescale 1ns / 1ps
//*************************************************************************
//   > 文件名: alu.v
//   > 描述  ：ALU模块，可做12种操作
//   > 作者  : Beckoning
//   > 日期  : 2024-05-09
//*************************************************************************
module alu(
    input  [3:0] alu_control,  // ALU控制信号,改为4位
    input  [31:0] alu_src1,     // ALU操作数1,为补码
    input  [31:0] alu_src2,     // ALU操作数2，为补码
    output [31:0] alu_result    // ALU结果
    );

    // ALU控制信号，独热码
    wire alu_add;   //加法操作
    wire alu_sub;   //减法操作
    wire alu_slt;   //有符号比较，小于置位，复用加法器做减法
    wire alu_sltu;  //无符号比较，小于置位，复用加法器做减法
    wire alu_and;   //按位与
    wire alu_nor;   //按位或非
    wire alu_or;    //按位或
    wire alu_xor;   //按位异或
    wire alu_sll;   //逻辑左移
    wire alu_srl;   //逻辑右移
    wire alu_sra;   //算术右移
    wire alu_lui;   //高位加载
    //新增三类运算，分别是算术左移，按位同或，低位加载
    wire alu_sla;   //算术左移
    wire alu_nxor;  //按位同或，就是按位异或的取反
    wire alu_hui;  //低位加载

    //修改此处代码，将其改为4位确定运算符号
    assign alu_add  = (~alu_control[3])&(~alu_control[2])&(~alu_control[1])&(alu_control[0]);//0001
    assign alu_sub  = (~alu_control[3])&(~alu_control[2])&(alu_control[1])&(~alu_control[0]);//0010
    assign alu_slt  = (~alu_control[3])&(~alu_control[2])&(alu_control[1])&(alu_control[0]); //0011
    assign alu_sltu = (~alu_control[3])&(alu_control[2])&(~alu_control[1])&(~alu_control[0]);//0100
    assign alu_and  = (~alu_control[3])&(alu_control[2])&(~alu_control[1])&(alu_control[0]); //0101
    assign alu_nor  = (~alu_control[3])&(alu_control[2])&(alu_control[1])&(~alu_control[0]); //0110
    assign alu_or   = (~alu_control[3])&(alu_control[2])&(alu_control[1])&(alu_control[0]);  //0111
    assign alu_xor  = (alu_control[3])&(~alu_control[2])&(~alu_control[1])&(~alu_control[0]);//1000
    assign alu_sll  = (alu_control[3])&(~alu_control[2])&(~alu_control[1])&(alu_control[0]); //1001
    assign alu_srl  = (alu_control[3])&(~alu_control[2])&(alu_control[1])&(~alu_control[0]); //1010
    assign alu_sra  = (alu_control[3])&(~alu_control[2])&(alu_control[1])&(alu_control[0]);  //1011
    assign alu_lui  = (alu_control[3])&(alu_control[2])&(~alu_control[1])&(~alu_control[0]); //1100
    //补充---------------------------------------------
    assign alu_sgt  = (alu_control[3])&(alu_control[2])&(~alu_control[1])&(alu_control[0]);  //1101
    assign alu_nxor  = (alu_control[3])&(alu_control[2])&(alu_control[1])&(~alu_control[0]); //1110
    assign alu_hui  = (alu_control[3])&(alu_control[2])&(alu_control[1])&(alu_control[0]);   //1111

    wire [31:0] add_sub_result;
    wire [31:0] slt_result;
    wire [31:0] sltu_result;
    wire [31:0] and_result;
    wire [31:0] nor_result;
    wire [31:0] or_result;
    wire [31:0] xor_result;
    wire [31:0] sll_result;
    wire [31:0] srl_result;
    wire [31:0] sra_result;
    wire [31:0] lui_result;
    wire [31:0] sgt_result;
    wire [31:0] nxor_result;
    wire [31:0] hui_result;
    
    assign and_result = alu_src1 & alu_src2;      // 与结果为两数按位与
    assign or_result  = alu_src1 | alu_src2;      // 或结果为两数按位或
    assign nor_result = ~or_result;               // 或非结果为或结果按位取反
    assign xor_result = alu_src1 ^ alu_src2;      // 异或结果为两数按位异或
    assign lui_result = {alu_src2[15:0], 16'd0};  // 立即数装载结果为立即数移位至高半字节
    
    wire adder_zero;
    assign adder_zero=|adder_result; 
    assign sgt_result[31:1] = 31'd0;
    assign sgt_result[0] = ~((alu_src1[31] & ~alu_src2[31]) | (~(alu_src1[31]^alu_src2[31]) & adder_result[31])) & adder_zero;
    
    assign nxor_result = ~xor_result;             // 同或结果为异或取反
    
    assign hui_result = { 16'd0,alu_src2[15:0]};

//-----{加法器}begin
//add,sub,slt,sltu均使用该模块
    wire [31:0] adder_operand1;
    wire [31:0] adder_operand2;
    wire        adder_cin     ;
    wire [31:0] adder_result  ;
    wire        adder_cout    ;
    assign adder_operand1 = alu_src1; 
    assign adder_operand2 = alu_add ? alu_src2 : ~alu_src2; 
    assign adder_cin      = ~alu_add; //减法需要cin 
    adder adder_module(
    .operand1(adder_operand1),
    .operand2(adder_operand2),
    .cin     (adder_cin     ),
    .result  (adder_result  ),
    .cout    (adder_cout    )
    );

    //加减结果
    assign add_sub_result = adder_result;
    assign slt_result[31:1] = 31'd0;
    assign slt_result[0]    = (alu_src1[31] & ~alu_src2[31]) | (~(alu_src1[31]^alu_src2[31]) & adder_result[31]);
    assign sltu_result = {31'd0, ~adder_cout};
    wire [4:0] shf;
    assign shf = alu_src1[4:0];
    wire [1:0] shf_1_0;
    wire [1:0] shf_3_2;
    assign shf_1_0 = shf[1:0];
    assign shf_3_2 = shf[3:2];
    
     // 逻辑左移
    wire [31:0] sll_step1;
    wire [31:0] sll_step2;
    assign sll_step1 = {32{shf_1_0 == 2'b00}} & alu_src2                   // 若shf[1:0]="00",不移位
                     | {32{shf_1_0 == 2'b01}} & {alu_src2[30:0], 1'd0}     // 若shf[1:0]="01",左移1位
                     | {32{shf_1_0 == 2'b10}} & {alu_src2[29:0], 2'd0}     // 若shf[1:0]="10",左移2位
                     | {32{shf_1_0 == 2'b11}} & {alu_src2[28:0], 3'd0};    // 若shf[1:0]="11",左移3位
    assign sll_step2 = {32{shf_3_2 == 2'b00}} & sll_step1                  // 若shf[3:2]="00",不移位
                     | {32{shf_3_2 == 2'b01}} & {sll_step1[27:0], 4'd0}    // 若shf[3:2]="01",第一次移位结果左移4位
                     | {32{shf_3_2 == 2'b10}} & {sll_step1[23:0], 8'd0}    // 若shf[3:2]="10",第一次移位结果左移8位
                     | {32{shf_3_2 == 2'b11}} & {sll_step1[19:0], 12'd0};  // 若shf[3:2]="11",第一次移位结果左移12位
    assign sll_result = shf[4] ? {sll_step2[15:0], 16'd0} : sll_step2;     // 若shf[4]="1",第二次移位结果左移16位

    // 逻辑右移
    wire [31:0] srl_step1;
    wire [31:0] srl_step2;
    assign srl_step1 = {32{shf_1_0 == 2'b00}} & alu_src2                   // 若shf[1:0]="00",不移位
                     | {32{shf_1_0 == 2'b01}} & {1'd0, alu_src2[31:1]}     // 若shf[1:0]="01",右移1位,高位补0
                     | {32{shf_1_0 == 2'b10}} & {2'd0, alu_src2[31:2]}     // 若shf[1:0]="10",右移2位,高位补0
                     | {32{shf_1_0 == 2'b11}} & {3'd0, alu_src2[31:3]};    // 若shf[1:0]="11",右移3位,高位补0
    assign srl_step2 = {32{shf_3_2 == 2'b00}} & srl_step1                  // 若shf[3:2]="00",不移位
                     | {32{shf_3_2 == 2'b01}} & {4'd0, srl_step1[31:4]}    // 若shf[3:2]="01",第一次移位结果右移4位,高位补0
                     | {32{shf_3_2 == 2'b10}} & {8'd0, srl_step1[31:8]}    // 若shf[3:2]="10",第一次移位结果右移8位,高位补0
                     | {32{shf_3_2 == 2'b11}} & {12'd0, srl_step1[31:12]}; // 若shf[3:2]="11",第一次移位结果右移12位,高位补0
    assign srl_result = shf[4] ? {16'd0, srl_step2[31:16]} : srl_step2;    // 若shf[4]="1",第二次移位结果右移16位,高位补0
 
    // 算术右移
    wire [31:0] sra_step1;
    wire [31:0] sra_step2;
    assign sra_step1 = {32{shf_1_0 == 2'b00}} & alu_src2                                 // 若shf[1:0]="00",不移位
                     | {32{shf_1_0 == 2'b01}} & {alu_src2[31], alu_src2[31:1]}           // 若shf[1:0]="01",右移1位,高位补符号位
                     | {32{shf_1_0 == 2'b10}} & {{2{alu_src2[31]}}, alu_src2[31:2]}      // 若shf[1:0]="10",右移2位,高位补符号位
                     | {32{shf_1_0 == 2'b11}} & {{3{alu_src2[31]}}, alu_src2[31:3]};     // 若shf[1:0]="11",右移3位,高位补符号位
    assign sra_step2 = {32{shf_3_2 == 2'b00}} & sra_step1                                // 若shf[3:2]="00",不移位
                     | {32{shf_3_2 == 2'b01}} & {{4{sra_step1[31]}}, sra_step1[31:4]}    // 若shf[3:2]="01",第一次移位结果右移4位,高位补符号位
                     | {32{shf_3_2 == 2'b10}} & {{8{sra_step1[31]}}, sra_step1[31:8]}    // 若shf[3:2]="10",第一次移位结果右移8位,高位补符号位
                     | {32{shf_3_2 == 2'b11}} & {{12{sra_step1[31]}}, sra_step1[31:12]}; // 若shf[3:2]="11",第一次移位结果右移12位,高位补符号位
    assign sra_result = shf[4] ? {{16{sra_step2[31]}}, sra_step2[31:16]} : sra_step2;    // 若shf[4]="1",第二次移位结果右移16位,高位补符号位

    assign alu_result = (alu_add|alu_sub) ? add_sub_result[31:0] : 
                    alu_slt           ? slt_result  :
                    alu_sltu          ? sltu_result :
                    alu_and           ? and_result  :
                    alu_nor           ? nor_result  :
                    alu_or            ? or_result   :
                    alu_xor           ? xor_result  :
                    alu_sll           ? sll_result  :
                    alu_srl           ? srl_result  :
                    alu_sra           ? sra_result  :
                    alu_lui           ? lui_result  :
                    alu_sgt           ? sgt_result  ://有符号数比较，大于置位
                    alu_nxor          ? nxor_result ://按位同或
                    alu_hui           ? hui_result  ://低位加载
                    32'd0;
endmodule
```



#### 4.2.2.2 alu_display.v

```verilog
//*************************************************************************
//   > 文件名: alu_display.v
//   > 描述  ：ALU显示模块，调用FPGA板上的IO接口和触摸屏
//   > 作者  : Beckoning
//   > 日期  : 2024-05-09
//*************************************************************************
module alu_display(
    //时钟与复位信号
     input clk,
    input resetn,    //后缀"n"代表低电平有效

    //拨码开关，用于选择输入数
    input [1:0] input_sel, //00:输入为控制信号(alu_control)
                           //10:输入为源操作数1(alu_src1)
                           //11:输入为源操作数2(alu_src2)

    //触摸屏相关接口，不需要更改
    output lcd_rst,
    output lcd_cs,
    output lcd_rs,
    output lcd_wr,
    output lcd_rd,
    inout[15:0] lcd_data_io,
    output lcd_bl_ctr,
    inout ct_int,
    inout ct_sda,
    output ct_scl,
    output ct_rstn
    );
//-----{调用ALU模块}begin
    reg   [3:0] alu_control;  // ALU控制信号
    reg   [31:0] alu_src1;     // ALU操作数1
    reg   [31:0] alu_src2;     // ALU操作数2
    wire  [31:0] alu_result;   // ALU结果
    alu alu_module(
        .alu_control(alu_control),
        .alu_src1   (alu_src1   ),
        .alu_src2   (alu_src2   ),
        .alu_result (alu_result )
    );

    reg         display_valid;
    reg  [39:0] display_name;
    reg  [31:0] display_value;
    wire [5 :0] display_number;
    wire        input_valid;
    wire [31:0] input_value;

    lcd_module lcd_module(
        .clk            (clk           ),   //10Mhz
        .resetn         (resetn        ),

        //调用触摸屏的接口
        .display_valid  (display_valid ),
        .display_name   (display_name  ),
        .display_value  (display_value ),
        .display_number (display_number),
        .input_valid    (input_valid   ),
        .input_value    (input_value   ),

        //lcd触摸屏相关接口，不需要更改
        .lcd_rst        (lcd_rst       ),
        .lcd_cs         (lcd_cs        ),
        .lcd_rs         (lcd_rs        ),
        .lcd_wr         (lcd_wr        ),
        .lcd_rd         (lcd_rd        ),
        .lcd_data_io    (lcd_data_io   ),
        .lcd_bl_ctr     (lcd_bl_ctr    ),
        .ct_int         (ct_int        ),
        .ct_sda         (ct_sda        ),
        .ct_scl         (ct_scl        ),
        .ct_rstn        (ct_rstn       )
    ); 

    //当input_sel为00时，表示输入数控制信号，即alu_control
    always @(posedge clk)
    begin
        if (!resetn)
        begin
            alu_control <= 12'd0;
        end
        else if (input_valid && input_sel==2'b00)
        begin
            alu_control <= input_value[3:0];
        end
    end
    
    //当input_sel为10时，表示输入数为源操作数1，即alu_src1
    always @(posedge clk)
    begin
        if (!resetn)
        begin
            alu_src1 <= 32'd0;
        end
        else if (input_valid && input_sel==2'b10)
        begin
            alu_src1 <= input_value;
        end
    end

    //当input_sel为11时，表示输入数为源操作数2，即alu_src2
    always @(posedge clk)
    begin
        if (!resetn)
        begin
            alu_src2 <= 32'd0;
        end
        else if (input_valid && input_sel==2'b11)
        begin
            alu_src2 <= input_value;
        end
    end

    always @(posedge clk)
    begin
        case(display_number)
            6'd1 :
            begin
                display_valid <= 1'b1;
                display_name  <= "SRC_1";
                display_value <= alu_src1;
            end
            6'd2 :
            begin
                display_valid <= 1'b1;
                display_name  <= "SRC_2";
                display_value <= alu_src2;
            end
            6'd3 :
            begin
                display_valid <= 1'b1;
                display_name  <= "CONTR";
                display_value <={20'd0, alu_control};
            end
            6'd4 :
            begin
                display_valid <= 1'b1;
                display_name  <= "RESUL";
                display_value <= alu_result;
            end
            default :
            begin
                display_valid <= 1'b0;
                display_name  <= 40'd0;
                display_value <= 32'd0;
            end
        endcase
    end
endmodule
```



# 五、实验结果分析

## 5.1 复现

​	首先观察一下我们的程序与硬件对应的部分

```verilog
    input [1:0] input_sel, //00:输入为控制信号(alu_control)
                           //10:输入为源操作数1(alu_src1)
                           //11:输入为源操作数2(alu_src2)
```

​	我们发现我们通过修改我们的两个按钮就可以控制我们的写入，我们在约束文件中找到对应的引脚，发现是第二个按钮和第八个按钮，然后我们就可以开始复现原来的项目了

​	我们按照前面所说的，输入两个数，`SRC-1`是$10101010$，`SRC-2`是$02020202$

|  SRC_1   |  SRC_2   | CONTR |       ALU操作        |  RESUL   |
| :------: | :------: | :---: | :------------------: | :------: |
| 10101010 | 02020202 |  000  |          无          | 00000000 |
| 10101010 | 02020202 |  800  |         加法         | 12121212 |
| 10101010 | 02020202 |  400  |         减法         | 0E0E0E0E |
| 10101010 | 02020202 |  200  | 有符号比较，小于置位 | 00000000 |
| 10101010 | 02020202 |  100  | 无符号比较，大于置位 | 00000000 |
| 10101010 | 02020202 |  080  |        按位与        | 00000000 |
| 10101010 | 02020202 |  040  |       按位或非       | EDEDEDED |
| 10101010 | 02020202 |  020  |        按位或        | 12121212 |
| 10101010 | 02020202 |  010  |       按位异或       | 12121212 |
| 10101010 | 02020202 |  008  |       逻辑左移       | 02020000 |
| 10101010 | 02020202 |  004  |       逻辑右移       | 00000202 |
| 10101010 | 02020202 |  002  |       算术右移       | 00000202 |
| 10101010 | 02020202 |  001  |       高位加载       | 02020000 |

> 由于此处截图数量过多，就不再展示实验截图了，将数据列成了表格

​	可以看出我们此处的运算全部都是正确的，说明我们的改进并没有影响原先的功能！



## 5.2 改进

​	我们首先先验证一下我们原来的那些运算的正确性，此处我们不改变两个输入数的值，只改变了中间的$CONTR$值，也就是将我们的位数做了改变。

|  SRC_1   |  SRC_2   | CONTR |       ALU操作        |  RESUL   |
| :------: | :------: | :---: | :------------------: | :------: |
| 10101010 | 02020202 |   0   |          无          | 00000000 |
| 10101010 | 02020202 |   1   |         加法         | 12121212 |
| 10101010 | 02020202 |   2   |         减法         | 0E0E0E0E |
| 10101010 | 02020202 |   3   | 有符号比较，小于置位 | 00000000 |
| 10101010 | 02020202 |   4   | 无符号比较，大于置位 | 00000000 |
| 10101010 | 02020202 |   5   |        按位与        | 00000000 |
| 10101010 | 02020202 |   6   |       按位或非       | EDEDEDED |
| 10101010 | 02020202 |   7   |        按位或        | 12121212 |
| 10101010 | 02020202 |   8   |       按位异或       | 12121212 |
| 10101010 | 02020202 |   9   |       逻辑左移       | 02020000 |
| 10101010 | 02020202 |   A   |       逻辑右移       | 00000202 |
| 10101010 | 02020202 |   B   |       算术右移       | 00000202 |
| 10101010 | 02020202 |   C   |       高位加载       | 02020000 |

​	可以看出我们这部分的结果都是正确的！

​	然后我们开始验证我们的新的三个运算，我们先验证最简单的**按位同或**

​	我们输入`SRC_1`=$11111111$，`SRC_2`=$11111111$时，将其转换为二进制数，按位同或后，转换成十六进制数，可以得到`RESUL`=$FFFFFFFF$，进行上箱验证。

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab4\2211044_陆皓喆_组成原理第四次实验.assets\image-20240509215523270.png" alt="image-20240509215523270" style="zoom:50%;" />

​	结果为$FFFFFFFF$，说明我们的程序是正确的

​	然后我们继续验证我们的**低位加载操作**：

​	我们输入两个数都是$11111111$，`SRC_2`的低$16$位将被加载到`RESUL`中，当`SRC_2`=$11111111$时，`RESUL`=$00001111$，进行上箱验证。

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab4\2211044_陆皓喆_组成原理第四次实验.assets\image-20240509215733716.png" alt="image-20240509215733716" style="zoom:50%;" />

​	结果正确，说明我们的程序没有问题！

​	然后我们来验证最复杂的一部分，也就是**有符号数的比较：大于则置位**

​	我们要分五部分来进行验证，首先是两个$0$来进行比较，我们应该输出的是$00000000$

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab4\2211044_陆皓喆_组成原理第四次实验.assets\image-20240509220115507.png" alt="image-20240509220115507" style="zoom:50%;" />

​	可以看出，结果是没有问题的

​	然后我们验证**正数与正数之间的比较**

​	我们输入两个数，一个是$114514$，一个是$12345$，很明显我们的第一个数应该比第二个数要大，所以应该输出$00000001$

![image-20240509220215967](E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab4\2211044_陆皓喆_组成原理第四次实验.assets\image-20240509220215967.png)

​	我们再相反的验证一遍，相反的话应该输出$00000000$

![image-20240509220608761](E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab4\2211044_陆皓喆_组成原理第四次实验.assets\image-20240509220608761.png)

​	可以看到，结果确实输出了我们想要的结果，没有问题

​	然后我们验证负数和正数之间的关系

​	我们输入的是：一个$FFFFFFFF$，一个是$00000001$，输出的应该是$00000000$，因为负数肯定小于正数

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab4\2211044_陆皓喆_组成原理第四次实验.assets\image-20240509220726644.png" alt="image-20240509220726644" style="zoom:50%;" />

​	结果没问题，说明我们的程序是正确的。

​	最后，我们再来比较两个负数之间的大小关系。

​	我们输入两个数，一个是$FFFFFFFF$，一个是$AAAAAAAA$，应该输出的是$00000001$

![image-20240509221511788](E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab4\2211044_陆皓喆_组成原理第四次实验.assets\image-20240509221511788.png)

​	**结果正确！以上我们所有的验证过程就全部结束了，此次实验完成。**



# 六、总结感想

​	本次实验，复现难度不大，就是把代码放到一起跑一下而已，但是对于代码的修改与增加功能，需要深入了解此次实验的代码构成以及前面的实验课的内容，都需要融会贯通，才能很快地完成本次实验。通过本次实验，更加理解了整个程序的流程以及实验箱的结构，进一步熟悉了$verilog$代码的编写；掌握了$ALU$模块的实现方式，以及不同运算的实现过程，为之后设计$CPU$打好了基础。