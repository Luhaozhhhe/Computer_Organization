# <center>组成原理实验课程第六次实验报告</center>

<h5 align="center">实验名称：单周期CPU实现   班级：李涛老师  学生姓名：陆皓喆  学号：2211044</h5 align="center">

<h5 align="center">指导老师：董前琨    实验地点：实验楼A306  实验时间：2024.05.30</h5 align="center">


# 一、实验目的

1. 理解$MIPS$指令结构，理解$MIPS$指令集中常用指令的功能和编码，学会对这些指令进行归纳分类。
2. 了解熟悉$MIPS$体系的处理器结构，如延迟槽，哈佛结构的概念。
3. 熟悉并掌握单周期$CPU$的原理和设计。
4. 进一步加强运用$verilog$语言进行电路设计的能力。
5. 为后续设计多周期$cpu$的实验打下基础。



# 二、实验内容说明

​	请结合实验指导手册中的实验六（单周期$CPU$实验）完成功能改进，在原有$CPU$基础上，扩充$CPU$可运行的$MIPS$指令，注意以下几点：

1. 扩充的指令应为一个时钟周期内能够执行完的指令，要求至少一个$R$型，一个$I$型，另外一个自选。建议在$ALU$实验改进基础上补充。
2. 实验报告中原理图为指导手册中的$display$模块图，不用修改，报告中的内容和展示的结果应扩充指令的步骤和实验结果。
3. 本次实验报告需要有实验箱上箱验证的照片，同样，针对照片中的数据需要解释说明。若只有仿真波形结果，会适当扣分。
4. 实验报告模板参考百度云盘文件，注意提交截至时间为$6$月$14$日下午$18:00$。



# 三、实验原理图

## 3.1 单周期CPU实现框图

![image-20240530102815269](E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240530102815269.png)

## 3.2 实验顶层模块框图

![image-20240530102929110](E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240530102929110.png)



# 四、单周期CPU指令执行

## 4.1 指令

​	单周期CPU能够执行MIPS指令集系统的一个子集，共16条指令，包括存储访问指令、运算指令、跳转指令。根据拥有的字段类型不同，我们将指令分为 **R 型指令**、**I 型指令 **和 **J 型指令**。

### 4.1.1 R 型指令

|  op  |  rs  |  rt  |  rd  | shamd | funct |
| :--: | :--: | :--: | :--: | :---: | :---: |

- op 段（6b）：恒为0b000000；

- rs（5b）、rt（5b） ：两个源操作数所在的寄存器号；

- rd（5b）：目的操作数所在的寄存器号；

- shamt（5位）：位移量，移位指令的移位位数；

- func（6b）：决定 R 型指令的具体功能。


### 4.1.2 I 型指令

|  op  |  rs  |  rt  | constant or address |
| :--: | :--: | :--: | :-----------------: |

- op段（6b）：决定 I 型指令类型；

- rs（5b）：是第一个源操作数所在的寄存器号；

- rt （5b）：是第二个源操作数所在的寄存器号 或 目的操作数所在的寄存器编号。

- constant or address（16b）：立即数或地址


### 4.1.3 J 型指令

|  op  | address |
| :--: | :-----: |

- op段（6b）：决定 J 型指令类型；

- constant or address（26b）：转移地址




## 4.2 不同指令的执行过程

### 4.2.1 R 型指令

- 从指令存储器中取指令，更新 PC 。
- ALU 根据 funct 字段确定 ALU 的功能。
- 从寄存器堆中读出寄存器 rs 和 rt。
- ALU 根据 2 中确定的功能，对从寄存器堆读出的数据进行操作。
- 将运算结果写入到 rd 字段对应的目标寄存器。

### 4.2.2 I 型指令

* 存取指令：
  * 从指令存储器中取指令，更新 PC 。

  * ALU 根据 op 字段确定 ALU 的功能。

  * 从寄存器堆中读出寄存器 rs 的值，并将其与符号扩展后的指令低16位立即数的值相加。

  * 若为存储指令，则将 rt 寄存器中的值存到上步相加得到的存储器地址；

  * 若为取数指令，则将 上步所得存储器地址里所存的数据放到 rt 目标寄存器中。

* 分支指令：
  * 从指令存储器中取指令，更新 PC 。
  * 从寄存器堆中读出寄存器 rs 和 rt 的值。
  * 将所读寄存器的两值相减。
  * 根据上步的结果是否为0，将 PC+4 的值或 address 字段所对应地址存入PC中。


### 4.2.3 J 型指令

- 从指令存储器中取指令，更新 PC 。
- 取出 address 字段，作为目标跳转地址。
- 将目标跳转地址存入PC中。



# 五、实验步骤

## 5.1 复现原实验

​	我们导入项目提供的一堆文件(如下图)，进行测试：

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240530130650155.png" alt="image-20240530130650155" style="zoom:50%;" />

​	我们把这些代码文件都加到我们的Lab6项目中，新建一个`single_cycle_cpu`的工程，`inst_rom.v`文件代码如下，其中包含了初始给定的一些指令：

```verilog
module inst_rom(
    input      [4 :0] addr, // 指令地址
    output reg [31:0] inst       // 指令
    );

    wire [31:0] inst_rom[19:0];  // 指令存储器，字节地址7'b000_0000~7'b111_1111
    //------------- 指令编码 ---------|指令地址|--- 汇编指令 -----|- 指令结果 -----//
    assign inst_rom[ 0] = 32'h24010001; // 00H: addiu $1 ,$0,#1   | $1 = 0000_0001H
    assign inst_rom[ 1] = 32'h00011100; // 04H: sll   $2 ,$1,#4   | $2 = 0000_0010H
    assign inst_rom[ 2] = 32'h00411821; // 08H: addu  $3 ,$2,$1   | $3 = 0000_0011H
    assign inst_rom[ 3] = 32'h00022082; // 0CH: srl   $4 ,$2,#2   | $4 = 0000_0004H
    assign inst_rom[ 4] = 32'h00642823; // 10H: subu  $5 ,$3,$4   | $5 = 0000_000DH
    assign inst_rom[ 5] = 32'hAC250013; // 14H: sw    $5 ,#19($1) | Mem[0000_0014H] = 0000_000DH
    assign inst_rom[ 6] = 32'h00A23027; // 18H: nor   $6 ,$5,$2   | $6 = FFFF_FFE2H
    assign inst_rom[ 7] = 32'h00C33825; // 1CH: or    $7 ,$6,$3   | $7 = FFFF_FFF3H
    assign inst_rom[ 8] = 32'h00E64026; // 20H: xor   $8 ,$7,$6   | $8 = 0000_0011H
    assign inst_rom[ 9] = 32'hAC08001C; // 24H: sw    $8 ,#28($0) | Mem[0000_001CH] = 0000_0011H
    assign inst_rom[10] = 32'h00C7482A; // 28H: slt   $9 ,$6,$7   | $9 = 0000_0001H
    assign inst_rom[11] = 32'h11210002; // 2CH: beq   $9 ,$1,#2   | 跳转到指令34H
    assign inst_rom[12] = 32'h24010004; // 30H: addiu $1 ,$0,#4   | 不执行
    assign inst_rom[13] = 32'h8C2A0013; // 34H: lw    $10,#19($1) | $10 = 0000_000DH
    assign inst_rom[14] = 32'h15450003; // 38H: bne   $10,$5,#3   | 不跳转
    assign inst_rom[15] = 32'h00415824; // 3CH: and   $11,$2,$1   | $11 = 0000_0000H
    assign inst_rom[16] = 32'hAC0B001C; // 40H: sw    $11,#28($0) | Men[0000_001CH] = 0000_0000H
    assign inst_rom[17] = 32'hAC040010; // 44H: sw    $4 ,#16($0) | Mem[0000_0010H] = 0000_0004H
    assign inst_rom[18] = 32'h3C0C000C; // 48H: lui   $12,#12     | [R12] = 000C_0000H
    assign inst_rom[19] = 32'h08000000; // 4CH: j     00H         | 跳转指令00H

    //读指令,取4字节
    always @(*)
    begin
        case (addr)
            5'd0 : inst <= inst_rom[0 ];
            5'd1 : inst <= inst_rom[1 ];
            5'd2 : inst <= inst_rom[2 ];
            5'd3 : inst <= inst_rom[3 ];
            5'd4 : inst <= inst_rom[4 ];
            5'd5 : inst <= inst_rom[5 ];
            5'd6 : inst <= inst_rom[6 ];
            5'd7 : inst <= inst_rom[7 ];
            5'd8 : inst <= inst_rom[8 ];
            5'd9 : inst <= inst_rom[9 ];
            5'd10: inst <= inst_rom[10];
            5'd11: inst <= inst_rom[11];
            5'd12: inst <= inst_rom[12];
            5'd13: inst <= inst_rom[13];
            5'd14: inst <= inst_rom[14];
            5'd15: inst <= inst_rom[15];
            5'd16: inst <= inst_rom[16];
            5'd17: inst <= inst_rom[17];
            5'd18: inst <= inst_rom[18];
            5'd19: inst <= inst_rom[19];
            default: inst <= 32'd0;
        endcase
    end
endmodule
```

​	我们可以发现，给出的`inst_rom[0]`到`inst_rom[19]`给出了我们实验中遇到的所有运算，分别对应了我们的00H到4CH。

我们对应的实验复现部分，在我们的实验结果分析的5.1节，此处就不再展示。



## 5.2 实验改进

我们选择以下三条对应的指令进行改进：

- 增加R型指令：按位同或
- 增加I型指令：低位加载
- 第三条指令：算术右移



### 5.2.1 single_cycle_cpu.v 文件

我们首先将我们新增加的三条指令加入到我们的指令列表中去。

* inst_NXOR 表示按位同或操作
* inst_HUI 表示低位加载操作
* inst_SRA 表示算术右移操作

```verilog
wire inst_NXOR, inst_HUI,inst_SRA;
```

然后，我们给这三个操作赋予我们的操作数：

```verilog
assign inst_NXOR  = (op == 6'b110001);                             // 逻辑同或运算
assign inst_HUI   = (op == 6'b110000);                             // 立即数装载低半字节
assign inst_SRA   = op_zero & (rs==5'd0) & (funct == 6'b000011);   // 算数右移             
```

然后，我们定义并实现传递到执行模块的 ALU 源操作数和操作码：

```verilog
wire inst_nxor, inst_hui,inst_sra;
assign inst_hui = inst_HUI;  // 立即数装载低位
assign inst_nxor = inst_NXOR;// 逻辑同或
assign inst_sra = inst_SRA;//算术右移
```

接着我们还需要修改我们的立即数拓展指令：

```verilog
assign inst_imm_sign = inst_ADDIU | inst_LUI | inst_LW | inst_SW | inst_HUI;
```

进行我们的符号偏移操作：

```verilog
wire   inst_shf_sa;    //使用sa域作为偏移量的指令
assign inst_shf_sa   = inst_SLL | inst_SRL | inst_SRA;
```

然后需要修改我们的独热码：

```verilog
assign alu_control = {inst_nxor,
                      inst_hui,
                      inst_add,        // ALU操作码，独热编码
                      inst_sub,
                      inst_slt,
                      inst_sltu,
                      inst_and
                      inst_nor,
                      inst_or, 
                      inst_xor,
                      inst_sll,
                      inst_srl,
                      inst_sra,
                      inst_lui};
```

最后，我们只需要修改我们的寄存器写回值就可以了，把新的三个寄存器都写入到我们的写回值中

```verilog
assign inst_wdest_rt = inst_ADDIU | inst_LW   | inst_LUI | inst_HUI;
assign inst_wdest_rd = inst_ADDU  | inst_SUBU | inst_SLT | inst_AND | inst_NOR
                     | inst_OR    | inst_XOR  | inst_SLL | inst_SRL | inst_NXOR| inst_SRA ;   
```



### 5.2.2  alu.v 文件

首先，我们需要扩展我们的ALU控制信号，我们由于需要添加三个指令，于是将其修改为**14位**

```verilog
input  [14:0] alu_control,  // ALU控制信号
```

添加独热码:

```verilog
wire alu_nxor;  //按位同或
wire alu_hui;   //低位加载
wire alu_sra;   //算术右移
```

添加控制信号:

```verilog
assign alu_hui  = alu_control[14];
assign alu_nxor = alu_control[13];
assign alu_sra = alu_control[12];
```

添加结果信号:

```verilog
wire [31:0] hui_result;
wire [31:0] nxor_result;
wire [31:0] sra_result;
```

添加运算逻辑:

```verilog
assign hui_result = {16'd0, alu_src2[15:0]};  // 立即数装载结果为立即数移位至低半字节

assign nxor_result= ~xor_result;              // 同或结果为异或结果按位取反  

wire [31:0] sra_step1;
wire [31:0] sra_step2;
assign sra_step1 = {32{shf_1_0 == 2'b00}} & alu_src2                                 // 若shf[1:0]="00",不移位
     | {32{shf_1_0 == 2'b01}} & {alu_src2[31], alu_src2[31:1]}           // 若shf[1:0]="01",右移1位,高位补符号位
     | {32{shf_1_0 == 2'b10}} & {{2{alu_src2[31]}}, alu_src2[31:2]}      // 若shf[1:0]="10",右移2位,高位补符号位
     | {32{shf_1_0 == 2'b11}} & {{3{alu_src2[31]}}, alu_src2[31:3]};     // 若shf[1:0]="11",右移3位,高位补符号位
assign sra_step2 = {32{shf_3_2 == 2'b00}} & sra_step1                                // 若shf[3:2]="00",不移位
     | {32{shf_3_2 == 2'b01}} & {{4{sra_step1[31]}}, sra_step1[31:4]}    // 若shf[3:2]="01",第一次移位结果右移4位,高位补符号位
     | {32{shf_3_2 == 2'b10}} & {{8{sra_step1[31]}}, sra_step1[31:8]}    // 若shf[3:2]="10",第一次移位结果右移8位,高位补符号位
     | {32{shf_3_2 == 2'b11}} & {{12{sra_step1[31]}}, sra_step1[31:12]}; // 若shf[3:2]="11",第一次移位结果右移12位,高位补符号位
assign sra_result = shf[4] ? {{16{sra_step2[31]}}, sra_step2[31:16]} : sra_step2;    // 若shf[4]="1",第二次移位结果右移16位,高位补符号位
```

添加选择结果输出:

```verilog
// 选择相应结果输出
assign alu_result = (alu_add|alu_sub) ? add_sub_result[31:0] : 
                    alu_slt           ? slt_result :
                    alu_sltu          ? sltu_result:
                    alu_and           ? and_result :
                    alu_nor           ? nor_result :
                    alu_or            ? or_result  :
                    alu_xor           ? xor_result :
                    alu_sll           ? sll_result :
                    alu_srl           ? srl_result :
                    alu_sra           ? sra_result :
                    alu_lui           ? lui_result :
                    alu_hui           ? hui_result :
                    alu_nxor          ? nxor_result:
                    alu_sra           ? sra_result:
                    32'd0;
```



### 5.2.3  inst_rom.v 文件

* 我们通过修改指令，使添加的指令能够运行并显示结果，我们添加如下三条指令：

```verilog
assign inst_rom[22] = 32'h000618C3; // 4CH: sra   $3,$6,3     | $3= FFFFFFFC
assign inst_rom[21] = 32'h00C76831; // 2CH: nxor $13,$6,$7    | $13 = FFFF_FFEEH
assign inst_rom[20] = 32'hC00E000E; // 30H: hui  $14,#14      | $14 = 0000_000EH
```



# 六、实验结果分析

## 6.1 原实验复现上箱

对工程进行综合和实现，烧入试验箱，然后我们对初始给出的这$20$条指令进行验证。

为了方便对验证各个寄存器中的数据是否执行正确，我们在每次执行`sw`指令后记录一次当前各个寄存器的值，以便进行数据的分析。

`sw $5,#19($1)`指令结束后，寄存器显示如下：

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240612183914858.png" alt="image-20240612183914858" style="zoom:67%;" />

在这条指令结束后，其前面的代码段完成了对寄存器`$1~$5`的赋值，并将`$5`寄存器的值存在了内存：`Mem[0000_0014H]`中。

我们以本段代码为例，详细解释计算过程，之后的sw指令便不再详细解释。

```verilog
addiu $1,$0,#1
```

该指令执行`$1=$0+1`，因此寄存器`$1`的值应变为00000001，与图片相符，验证正确。

```verilog
sll $2,$1,#4
```

该指令将`$1`左移四位后再赋值给`$2`，因此`$2`值应为00000010，与图片相符，验证正确。

```verilog
addu $3,$2,$1
```

该指令执行`$3=$2+$1`,因此`$3`的值应为00000011，与图片相符，验证正确。

```verilog
srl $4,$2,#2
```

该指令把`$2`右移2位后传给`$4`，因此`$4`的值应为00000004，与图片相符，验证正确。

```verilog
subu $5,$3,$4
```

该指令执行`$5=$3-$4`，因此`$45的值应为0000000D，与图片相符，验证正确。

```verilog
sw $5,#19($1)
```

该指令把`$5`的值存入内存：`Mem[0000_0014H]`，为验证该结果，我们把`MADDR`输入14，读得`MDATA`为0000000D，证明写入内存成功，验证正确。

综上，验证了说明各个寄存器中的数据执行正确。

下面的代码我们就不一一分析了，我们只看每一处的sw指令就可以了。

`sw $8,#28($0)`指令结束后，寄存器显示如下：

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240612204501461.png" alt="image-20240612204501461" style="zoom: 67%;" />

该代码段完成了对寄存器`$6~$8`的赋值，并将`$8`寄存器的值存在了内存：`Mem[0000_001CH]`中。

我们通过读取内存中的值，`Mem[0000_001CH]`处的值确实为`$8`中数值，并检验各个寄存器的值，都是正确的，可以说明程序执行成功。

`beq $9 ,$1,#2`指令结束后，寄存器显示如下：

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240612204627783.png" alt="image-20240612204627783" style="zoom: 67%;" />

由于`$9≠$1`，因此跳转到`PC+2<<2=34H`的地址处，与照片相符，证明跳转指令执行成功。

`sw $4 ,#16($0)`指令结束后，寄存器显示如下：

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240612204706642.png" alt="image-20240612204706642" style="zoom:67%;" />

该步骤结束后，`Mem[0000_0010H]`应存放`$4` 的值00000004，与图片相符，验证正确性。同时其余各个寄存器的值都与程序正常运行后的相符，说明**指令均执行成功。**我们的复现部分就到此结束了。



## 6.2 实验改进后上箱

### 6.2.1 按位同或操作

按动实验箱上按钮，每次运行一条 CPU 指令，按照设定，当第11条指令执行时，指令编码为0x00C76831，对应的汇编语句为

```asm
nxor $13, $6, $7
```

表示将`$6`和`$7`进行按位同或运算，将得到的结果存入`$13`中。按照设定，此处的`$6`的值为0xFFFFFFE2，`$7`的值为0xFFFFFFF3，运算得到的结果为0xFFFFFFEE。

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240612222844970.png" alt="image-20240612222844970" style="zoom:67%;" />

如图所示，`REG0D`中的值确为0xFFFFFFEE，说明逻辑正确。



### 6.2.2 低位加载操作

按照设定，当第12条指令执行时，指令编码为0xC00E000E，对应的汇编语句为

```asm
hui $14, #14
```

表示将立即数`14`按低位加载的模式加载到寄存器`$14`中。按照设定，寄存器`$14`中的值应为0x0000000E。

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240612222947351.png" alt="image-20240612222947351" style="zoom:67%;" />

如图所示，`$14`中的值确为0x0000000E，说明逻辑正确。



### 6.2.3 算术右移操作

下图是执行该语句之前的截图：

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240612223106365.png" alt="image-20240612223106365" style="zoom:50%;" />

执行我们的指令`sra $3,$6,3`后，我们得到下图：

<img src="E:\学学学\本科\大二下\计算机组成原理\实验报告_2211044_陆皓喆\Lab6\2211044_陆皓喆_组成原理第六次实验.assets\image-20240612223203284.png" alt="image-20240612223203284" style="zoom: 67%;" />

可以发现，如图所示，在`sra $3,$6,3` 执行后，我们观察到`$3`寄存器的值变成了0xFFFFFFFC ，说明算数右移指令
执行成功，这与我们预期结果是相同的，证明该指令添加无误。

以上就是我们对于三条指令的对应验证。



# 七、总结感想

* 通过本次实验，我系统理解了单周期CPU的原理和实现。单周期CPU即一个时钟周期完成整个任务
* 对verilog编程语言有了更加深刻的了解，为以后尝试多周期CPU的实验奠定基础
* 此外，我学会了如何通过分析指令格式来在现有CPU中添加新的指令类型，包括三种常见的指令类型
* 本次实验让我把前面所学的所有实验知识融会贯通，加深了对计算机CPU的认识，让我获益匪浅

> ***最后，我还想感谢一下董老师，对于我在实验中遇到的很多问题，比如说第二次实验，第四次实验，矩阵乘法大作业中遇到的难点，都能给我很好的解答，使我能够高效率地完成我的实验课部分的实验和实验报告。***

**本学期的实验部分就到此结束了！！！**

**本学期的计算机组成原理课程实验项目均放在本人的github仓库下**

地址：[NKU-CSSE0046-计算机组成原理](https://github.com/Luhaozhhhe/Computer_Organization)

